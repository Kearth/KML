## 架构

> 架构，又名软件架构**，**是有关软件整体结构与组件的抽象描述，用于指导大型软件系统各个方面的设计 

- #### 秒杀系统

  场景：天猫商城秒杀、小米商城秒杀、12306购票

  难点：多人读取同一份数据，读写冲突多，锁非常严重。

  思路：尽量在系统上游拦截请求、读多写少尽量利用缓存

  方案：

  **客户端**：

  - 页面提交按钮点击后置灰，防止重复提交，等待结果返回

  **站点层**：

  - 对uid进行去重，同时做页面缓存。X秒内的请求只有一次通过站点层，其余返回之前的页面缓存。
  - 站点层压力最大，如果并发请求过大，可以采用机器扩容。如果机器不够，抛弃部分请求。

  **服务层**

  - 写请求上限量已知，与秒杀商品数量一致。只放入比商品量稍多的请求到队列去写库，其余都返回已售完。读请求直接读缓存。

  - 业务规则上，结合实际需求。有的可以采取分段秒杀，均摊流量。有的可以库存粗粒度化，只提供有无缓存查询即可。

  **数据层**

  - 正常数据落地

- #### 分布式ID生成

  场景：订单ID，消息ID

  难点：这个ID常用于唯一主键并可能有分页排序等业务需求。

  思路：全局唯一、趋势有序递增

  方案：方法有很多种，经过筛选，选取了twitter的snowflake算法作为指导思想

  **核心思想**

  通过snowflake生成一个long（64bit）型ID，

  第1bit 固定为0，因为ID为正整数。

  随后41bit存储时间戳， 约可以存69年左右数据。  

  随后5bit datacenterId 数据中心ID，最多32个。

  随后5bit workerId 机器ID 最多32个。

  最后12bit 序列号 同一毫秒生成的4096个序号。

  这个算法可以结合实际的业务逻辑做些调整。比如41bit时间戳表示的69年一般系统不会存在那么久，可以减少一两个bit。其后的10bit机器号也可以调整位数，比如取出4bit代表业务线，这样就可以维护16个业务的ID生成。

  缺点：不同生成服务器的时间会有差异，导致在很短时间内ID并不是绝对递增的。ID如果作为分库分表取模的依据，那么跨毫秒时归零会导致ID生成不均匀。有文章指出此处应该归零时随机0-9，经分析不妥。生成ID均匀与否与每毫秒访问单机生成器的请求数有关，两个极端分别是末尾全为0和末尾各序号完全均匀。所以业务运行中，不管随机补偿为任一值，都不必然均匀。建议此处分表可以不以ID取模为依据，而用中间机器号10bit（0-1023）进行分库分表，因为生成器服务请求均分，因而分库分表相对均匀。

  优点：全局唯一，趋势递增，每秒最多生成400W个ID

- #### 缓存架构

